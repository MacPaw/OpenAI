//
//  AudioChatResult.swift
//
//
//  Created by OpenAI SDK Contributors.
//

import Foundation

/// Response from an audio chat completion request
public struct AudioChatResult: Codable, Equatable, Sendable {
    /// A unique identifier for the chat completion
    public let id: String

    /// The object type, always "chat.completion"
    public let object: String

    /// The Unix timestamp (in seconds) of when the chat completion was created
    public let created: Int

    /// The model used for the chat completion
    public let model: Model

    /// A list of chat completion choices
    public let choices: [Choice]

    /// Usage statistics for the completion request
    public let usage: Usage?

    /// The service tier used for processing the request
    public let serviceTier: String?

    /// This fingerprint represents the backend configuration that the model runs with
    public let systemFingerprint: String?

    enum CodingKeys: String, CodingKey {
        case id
        case object
        case created
        case model
        case choices
        case usage
        case serviceTier = "service_tier"
        case systemFingerprint = "system_fingerprint"
    }

    public init(
        id: String,
        object: String,
        created: Int,
        model: Model,
        choices: [Choice],
        usage: Usage? = nil,
        serviceTier: String? = nil,
        systemFingerprint: String? = nil
    ) {
        self.id = id
        self.object = object
        self.created = created
        self.model = model
        self.choices = choices
        self.usage = usage
        self.serviceTier = serviceTier
        self.systemFingerprint = systemFingerprint
    }

    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let parsingOptions = decoder.userInfo[.parsingOptions] as? ParsingOptions ?? []
        self.id = try container.decodeString(forKey: .id, parsingOptions: parsingOptions)
        self.object = try container.decodeString(forKey: .object, parsingOptions: parsingOptions)
        self.created = try container.decode(Int.self, forKey: .created)
        self.model = try container.decode(Model.self, forKey: .model)
        self.choices = try container.decode([Choice].self, forKey: .choices)
        // Handle empty usage object gracefully
        self.usage = try? container.decodeIfPresent(Usage.self, forKey: .usage)
        self.serviceTier = try container.decodeIfPresent(String.self, forKey: .serviceTier)
        self.systemFingerprint = try container.decodeIfPresent(String.self, forKey: .systemFingerprint)
    }

    public struct Choice: Codable, Equatable, Sendable {
        /// The index of the choice in the list of choices
        public let index: Int

        /// A chat completion message generated by the model
        public let message: Message

        /// The reason the model stopped generating tokens
        public let finishReason: String?

        enum CodingKeys: String, CodingKey {
            case index
            case message
            case finishReason = "finish_reason"
        }
    }

    public struct Message: Codable, Equatable, Sendable {
        /// The role of the author of this message
        public let role: String

        /// The text content of the message
        public let content: String?

        /// Audio output from the model
        public let audio: AudioOutput?

        enum CodingKeys: String, CodingKey {
            case role
            case content
            case audio
        }
    }

    /// Audio output from the model
    public struct AudioOutput: Codable, Equatable, Sendable {
        /// Unique identifier for the audio response
        public let id: String

        /// Base64-encoded audio data
        public let data: String

        /// Transcript of the audio
        public let transcript: String

        /// Unix timestamp (in seconds) when this audio data expires
        public let expiresAt: Int

        enum CodingKeys: String, CodingKey {
            case id
            case data
            case transcript
            case expiresAt = "expires_at"
        }
    }

    /// Usage statistics for the completion request
    public struct Usage: Codable, Equatable, Sendable {
        /// Number of tokens in the prompt
        public let promptTokens: Int

        /// Number of tokens in the generated completion
        public let completionTokens: Int

        /// Total number of tokens used in the request (prompt + completion)
        public let totalTokens: Int

        /// Breakdown of tokens used in the prompt
        public let promptTokensDetails: TokenDetails?

        /// Breakdown of tokens used in the completion
        public let completionTokensDetails: TokenDetails?

        enum CodingKeys: String, CodingKey {
            case promptTokens = "prompt_tokens"
            case completionTokens = "completion_tokens"
            case totalTokens = "total_tokens"
            case promptTokensDetails = "prompt_tokens_details"
            case completionTokensDetails = "completion_tokens_details"
        }

        /// Detailed breakdown of token usage
        public struct TokenDetails: Codable, Equatable, Sendable {
            /// Number of text tokens
            public let textTokens: Int?

            /// Number of audio tokens
            public let audioTokens: Int?

            enum CodingKeys: String, CodingKey {
                case textTokens = "text_tokens"
                case audioTokens = "audio_tokens"
            }
        }
    }
}
